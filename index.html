<hmtl>
<head>
  <title>🚶‍♀️ trip</title>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
html, body {
  font-family: sans-serif;
  line-height: 1.2;
  background-color: #eeeeee;
  color: #111111;
}
button {
  width: 100%;
  padding: 1em;
  background: darkslateblue;
  color: aliceblue;
  font-size: 2em;
  border: 1px solid black;
  border-radius: 5px;
  margin: 1em 0;
}
  </style>
</head>
<body>
  <h1>Trip 🚶‍♀️</h1>
  <p>hey johnny this page will ask for permission to access your location. You must answer YES in order for any of this to work.</p>
  <h2>Check in ✅</h2>
  <p id="checkins"></p>
  <div id="status"></div>
  <button>Check in</button>
  <div id="locations">
    <h2>All Locations 📌</h2>
  </div>
</body>
  <script>
(async () => {

// all locations are loaded from a static JSON file hosted on github
const res = await fetch('https://raw.githubusercontent.com/chrisman/trip/master/locations.json')
const locations = await res.json()

const consts = {
  item: 'trip',
  range: 100,
}
const state = {
  lat: 0,
  long: 0,
  canCheckIn: false,
}

// localstorage data layer
const data = {
  get() {
    return parse(localStorage.getItem(consts.item)) || []
  },
  add(x) {
    const checkins = this.get()
    if(checkins.filter(c => c.name === x.name).length > 0) {
      return false
    } else {
      localStorage.setItem(consts.item, stringify(this.get().concat(x)))
      return true
    }
  },
}

const { parse, stringify } = JSON

// pretty much copypasted from https://www.geodatasource.com/developers/javascript
const distanceInFeet = ([lat1, lon1], [lat2, lon2]) => {
  const { sin, cos, acos, PI: pi } = Math
  const rad = x => pi * x/180
  const [ radlat1, radlat2, radtheta ] = [lat1, lat2, (lon1 - lon2)].map(rad)
  let dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta)
  dist = (dist > 1) ? 1 : dist
  dist = acos(dist)
  dist = dist * 180/pi // i don't know what any of these numbers are
  dist = dist * 60 * 1.1515 * 5280 // lol
  return dist
}

// this object contains the three parameters to be passed to `navigator.geolocation.watchPosition`:
// a `success` callback, an `error` callback, and an `options` object
const geo = {
  success({ coords: { latitude: lat, longitude: long } }) {
    state.lat  = lat
    state.long = long

    const distances        = locations.map(({ lat: lt, long: lng }) => distanceInFeet([state.lat, state.long], [lt, lng]))
    const shortestDistance = distances.reduce((a, b) => a < b ? a : b)
    const nearestLocation  = locations[distances.indexOf(shortestDistance)]

    state.canCheckIn = shortestDistance < consts.range

    dom.status.innerHTML = `Your location: ${state.lat}, ${state.long}`
    dom.status.innerHTML += `<br>The nearest location is ${nearestLocation.name}`
    dom.status.innerHTML += `<br>You are ${Math.floor(shortestDistance)} feet away`
    dom.status.innerHTML += `<br>You must be within ${consts.range} feet to check in`
    dom.status.innerHTML += `<br>You are ${state.canCheckIn ? '' : 'not'} close enough to check in`
      
  },
  error() {
    console.error('Geolocation unavailable') 
    dom.status.innerHTML = `Geolocation unavailable`
    dom.status.innerHTML += `<br>Try <a href="#" onclick="locate()">clicking here</a>`
    dom.status.innerHTML += `<br>If that doesn't work try reloading the page`
  },
  options: {
    enableHighAccuracy: true, 
    maximumAge: 30000, 
    timeout: 27000,
  },
}

// query selectors, and update functions for elements that are updated from various places
const dom = {
  button: document.querySelector('button'),
  locations: document.querySelector('#locations'),
  status: document.querySelector('#status'),
  checkins: {
    selector: document.querySelector('#checkins'),
    update() {
      const len = data.get().length
      dom.checkins.selector.innerHTML = `Total checks in: ${len}/${locations.length}`
      if(len === locations.length) {
        dom.checkins.selector.innerHTML += `<marquee><h1>🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉</h1></marquee>`
        dom.checkins.selector.innerHTML += `<h1>YOU WIN! <a href="mailto:chris.brown+crawl@skookum.com?subject=crawl%20complete">Send this email to complete your submission</a></h1>`
        dom.checkins.selector.innerHTML += `<marquee><h1>🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉</h1></marquee>`
      }
    }, 
  }
}

// this violates the "Only request geolocation information in response to a user gesture" rule, but
const locate = () => {
  if (!navigator.geolocation) {
    window.alert('This app requires geolocation services')
  } else {
    dom.status.textContent = 'Locating...'
    const id = navigator.geolocation.watchPosition(geo.success, geo.error, geo.options);
  }
}

// TODO please this whole function is stupid
const checkin = () => {
  const success = 'SUCCESS! 🎉'
  const failure = 'Too far, or already checked in'
  if (state.canCheckIn) {
    const distances        = locations.map(({ lat: lt, long: lng }) => distanceInFeet([state.lat, state.long], [lt, lng]))
    const shortestDistance = distances.reduce((a, b) => a < b ? a : b)
    const nearestLocation  = locations[distances.indexOf(shortestDistance)]

    // TODO/FIXME: this is gross and side-effect-y 
    // also this needs more robust error reporting
    // i.e. is it a distance failure or a duplicate failure?
    if(data.add(nearestLocation)) {
      dom.checkins.update()
    } else {
      state.canCheckIn = false
    }
  }
  window.alert(state.canCheckIn ? success : failure)
}

// kick things off
const init = () => {
  dom.button.addEventListener('click', checkin)
  locations.forEach(location => {
    dom.locations.innerHTML += `<li>${location.name}: ${location.lat}, ${location.long}</li>`
  })
  dom.checkins.update()
  locate();
}
init()

})()
  </script>
</html>
